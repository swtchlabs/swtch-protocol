import {
    time,
    loadFixture,
} from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { expect, use } from "chai";
import hre from "hardhat";
import { upgrades } from "hardhat";
// import { ImplementationV1, ImplementationV2, UUPSProxy } from "../typechain-types";

describe("UpgradeManager", function () {
  let UpgradeManagerFactory: hre.ethers.Contract;
  let upgradeManager: hre.ethers.Contract;
  let implementationV1: hre.ethers.Contract;
  let implementationV2: hre.ethers.Contract;
  
  let owner: hre.ethers.Signer;
  let addr1: hre.ethers.Signer;
  let addr2: hre.ethers.Signer;
  let addr3: hre.ethers.Signer;
  
  let proxy: hre.ethers.Contract;

  before(async function () {
    [owner, addr1, addr2, addr3] = await hre.ethers.getSigners();

    // Deploy ImplementationV1
    const ImplementationV1 = await hre.ethers.getContractFactory("ImplementationV1");
    implementationV1 = await ImplementationV1.deploy();
    await implementationV1.getDeployedCode();

    // Deploy ImplementationV2
    const ImplementationV2 = await hre.ethers.getContractFactory("ImplementationV2");
    implementationV2 = await ImplementationV2.deploy();
    await implementationV2.getDeployedCode();

    // Deploy Proxy using ImplementationV1
    proxy = await upgrades.deployProxy(ImplementationV1, [], { initializer: 'initialize' });

    // Deploy UpgradeManager
    UpgradeManagerFactory = await hre.ethers.getContractFactory("UpgradeManager");
    
    const proxyAddress = await proxy.getAddress();
    const signers = [owner.address, addr1.address, addr2.address];
    // upgradeManager = await UpgradeManagerFactory.deploy(proxyAddress, signers);
    // await upgradeManager.getDeployedCode();
  });

  it("should propose an upgrade correctly", async function () {
    // const implV2 = await implementationV2.getAddress();
    // let upgrade = upgradeManager.connect(owner).proposeUpgrade(implV2);

    // await expect(upgradeManager.connect(addr1).proposeUpgrade(implV2))
    //   .to.emit(upgradeManager, "UpgradeInitiated");
    // const proposal = await upgradeManager.proposals(0);
    // expect(proposal.newImplementation).to.equal(implV2);
  });

//   it("should allow signers to approve the upgrade", async function () {
//     await upgradeManager.connect(owner).approveUpgrade(0);
//     await upgradeManager.connect(addr1).approveUpgrade(0);
//     await expect(upgradeManager.connect(addr2).approveUpgrade(0))
//       .to.emit(upgradeManager, "UpgradeApproved").withArgs(0, await addr2.getAddress());
//   });

//   it("should upgrade the contract after all approvals", async function () {
//     // After the last approval, the upgrade should be executed automatically
//     const implV2 = await implementationV2.getAddress();
//     expect(await proxy.implementation()).to.equal(implV2);
//   });

  // it("should reject approvals from non-signers", async function () {
  //   await expect(upgradeManager.connect(addr3).approveUpgrade(0))
  //     .to.be.revertedWith("Caller is not a signer");
  // });
});


// describe("UUPSToken", function () {
//     let dao: hre.ethers.Contract;
//     let token: hre.ethers.Contract;
//     let owner: hre.ethers.Signer, addr1: hre.ethers.Signer;
    
//     beforeEach(async function () {
//         [owner, addr1] = await hre.ethers.getSigners();
//         const DAO = await hre.ethers.getContractFactory("DAO");
//         dao = await DAO.deploy();
//         await dao.getDeployedCode();
        
//         const Token = await hre.ethers.getContractFactory("UUPSToken");
//         // token = await upgrades.deployProxy(Token, ["MyToken", "MTK", await dao.getAddress()], { initializer: 'initialize' });
//         token = await upgrades.deployProxy(Token, ["MyToken", "MTK", hre.ethers.parseUnits("1000000", 18), owner.address, await dao.getAddress()], { initializer: 'initialize' });
//     });

//     it("should assign the total supply of tokens to the owner", async function () {
//         const ownerBalance = await token.balanceOf(owner.address);
//         expect(await token.totalSupply()).to.be.greaterThan(0);
//         expect(await token.totalSupply()).to.equal(ownerBalance);
//     });

//     it("transfers tokens between accounts", async function () {
//         const ownerBalance = await token.balanceOf(owner.address);
//         // Transfer 50 tokens from owner to addr1
//         await token.connect(owner).transfer(addr1.address, 50);
//         expect(await token.balanceOf(addr1.address)).to.equal(50);
//         const remainder = ownerBalance - hre.ethers.toBigInt(50);
//         expect(await token.balanceOf(owner.address)).to.equal(remainder);
//     });

//     it("upgrades the token contract and accesses new functionality", async function () {
//         const TokenV2 = await hre.ethers.getContractFactory("UUPSTokenV2");
//         const proposalId = hre.ethers.toBigInt(1);
//         // governance should have approved the proposal id
//         await token.proposeUpgrade(proposalId);

//         const upgradedToken = await upgrades.upgradeProxy(await token.getAddress(), TokenV2);
    
//         // Access new function in V2
//         expect(await upgradedToken.newFunction()).to.equal("New functionality!");
//     });
// });
