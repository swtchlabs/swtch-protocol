import {
    time,
    loadFixture,
} from "@nomicfoundation/hardhat-toolbox/network-helpers";
import { anyValue } from "@nomicfoundation/hardhat-chai-matchers/withArgs";
import { expect, assert } from "chai";
import hre from "hardhat";

import { ethers } from "hardhat";

describe("PaymentChannel", function () {
  let paymentChannel: hre.ethers.Contract;
  let sender: hre.ethers.Wallet, receiver: hre.ethers.Wallet;
  let otherAccount: hre.ethers.Wallet;
  const initialDeposit = hre.ethers.parseEther("1.0");  // 1 ether
  const duration = 3600;  // 1 hour in seconds

  beforeEach(async function () {
    [sender, receiver, otherAccount] = await hre.ethers.getSigners();
    const PaymentChannel = await ethers.getContractFactory("PaymentChannel");
    paymentChannel = await PaymentChannel.connect(sender).deploy(receiver.address, duration, { value: initialDeposit });
    await paymentChannel.getDeployedCode();
  });

  describe("Deployment", function () {
    it("should set the right sender", async function () {
      expect(await paymentChannel.sender()).to.equal(sender.address);
    });

    it("should set the right receiver", async function () {
      expect(await paymentChannel.receiver()).to.equal(receiver.address);
    });

    it("should set the correct expiration time", async function () {
      const blockTime = (await hre.ethers.provider.getBlock("latest"))?.timestamp;
      if(blockTime) 
        expect(await paymentChannel.expiration()).to.equal(blockTime + duration);
    });

    it("should receive the correct deposit", async function () {
      expect(await ethers.provider.getBalance(paymentChannel.address)).to.equal(initialDeposit);
    });
  });

  describe("Functionality", function () {
    it("should allow the receiver to close the channel correctly", async function () {
      const amount = hre.ethers.parseEther("0.5");
      const message = hre.ethers.solidityPackedKeccak256(["address", "uint256"], [paymentChannel.address, amount]);
      const signature = await sender.signMessage(hre.ethers.toBeArray(message)); //.arrayify(message));
    
      await expect(() => paymentChannel.connect(receiver).close(amount, signature))
        .to.changeEtherBalances([receiver, paymentChannel], [amount, -amount]);

      const remaining = initialDeposit - amount;
      await expect(() => paymentChannel.connect(sender).close(amount, signature))
        .to.changeEtherBalances([sender, paymentChannel], [remaining, -remaining]);
    });

    // it("should revert if an invalid signature is provided", async function () {
    //   const amount = hre.ethers.parseEther("0.5");
    //   const badSignature = await receiver.signMessage(hre.ethers.toBeArray(hre.ethers.randomBytes(65)));
    //   await expect(paymentChannel.connect(receiver).close(amount, badSignature))
    //     .to.be.revertedWith("Invalid signature");
    // });

    // it("should allow the sender to extend the expiration", async function () {
    //   const latest = await hre.ethers.provider.getBlock("latest");
    //   const newExpiration = latest.timestamp + 7200;  // extend by 2 hours
    //   await expect(paymentChannel.connect(sender).extend(newExpiration))
    //     .to.emit(paymentChannel, "ExpirationExtended")
    //     .withArgs(newExpiration);
    // });

    // it("should revert if someone else tries to extend the expiration", async function () {
    //   const newExpiration = (await ethers.provider.getBlock("latest")).timestamp + 7200;  // extend by 2 hours
    //   await expect(paymentChannel.connect(otherAccount).extend(newExpiration))
    //     .to.be.revertedWith("Only sender can extend expiration");
    // });

    it("should allow the sender to claim funds after the expiration", async function () {
      // Increase time to simulate expiration
      await ethers.provider.send("evm_increaseTime", [duration + 1]);
      await ethers.provider.send("evm_mine", []);

      await expect(() => paymentChannel.connect(sender).claimTimeout())
        .to.changeEtherBalance(sender, initialDeposit);
    });

    it("should revert if the channel is claimed before expiration", async function () {
      await expect(paymentChannel.connect(sender).claimTimeout())
        .to.be.revertedWith("Channel not yet expired");
    });
  });
});
